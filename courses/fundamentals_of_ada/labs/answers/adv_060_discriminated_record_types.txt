with Ada.Characters.Handling; use Ada.Characters.Handling;
with Ada.Text_IO;             use Ada.Text_IO;
package body Input is
   function Get_String
     (Prompt : String)
      return String is
      Str  : String (1 .. 100);
      Last : Integer;
   begin
      Put (Prompt & " > ");
      Ada.Text_IO.Get_Line (Str, Last);
      return Str (1 .. Last);
   end Get_String;
   function Get_Number
     (Prompt : String)
      return Integer_T is
   begin
      loop
         declare
            Retval : constant String := Get_String (Prompt);
         begin
            if Retval'length > 0 then
               return Integer_T'value (Retval);
            else
               raise Input_Canceled;
            end if;
         exception
            when others =>
               Put_Line ("Invalid input");
         end;
      end loop;
   end Get_Number;
   function Get_Enum
     (Prompt : String)
      return Enum_T is
   begin
      for E in Enum_T'range loop
         Put_Line
           (Integer'image (1 + Enum_T'pos (E)) & "> " & Enum_T'image (E));
      end loop;
      loop
         declare
            I : constant String := Get_String (Prompt);
         begin
            if I'length = 0 then
               raise Input_Canceled;
            end if;
            return Enum_T'val (Natural'value (I) - 1);
         exception
            when Input_Canceled =>
               raise Input_Canceled;
            when others =>
               Put_Line ("Illegal value");
         end;
      end loop;
   end Get_Enum;
   function Internal_Get_Integer is new Get_Number (Integer);
   function Internal_Get_Natural is new Get_Number (Natural);
   function Internal_Get_Positive is new Get_Number (Positive);
   function Get_Integer
     (Prompt : String)
      return Integer renames Internal_Get_Integer;
   function Get_Natural
     (Prompt : String)
      return Natural renames Internal_Get_Natural;
   function Get_Positive
     (Prompt : String)
      return Positive renames Internal_Get_Positive;
end Input;
package Input is
   Input_Canceled : exception;
   function Get_String
     (Prompt : String)
      return String;
   function Get_Integer
     (Prompt : String)
      return Integer;
   function Get_Natural
     (Prompt : String)
      return Natural;
   function Get_Positive
     (Prompt : String)
      return Positive;
   generic
      type Enum_T is (<>);
   function Get_Enum
     (Prompt : String)
      return Enum_T;
   generic
      type Integer_T is range <>;
   function Get_Number
     (Prompt : String)
      return Integer_T;
end Input;
--Main
with Ada.Text_IO; use Ada.Text_IO;
with Input;       use Input;
with Scheduling;
procedure Main is
   type Commands_T is (Add, Attend, Teach, Print, Quit);
   function Command is new Get_Enum (Commands_T);
   function Kind is new Get_Enum (Scheduling.Kind_T);
   Database : array (1 .. 100) of Scheduling.Person_T;
   Current  : Integer := 0;
begin
   loop
      case Command ("Select command") is
         when Add =>
            Current            := Current + 1;
            Database (Current) := Scheduling.Create
                (First_Name => Get_String ("First Name"),
                 Last_Name  => Get_String ("Last Name"),
                 Kind       => Kind ("Kind"));
         when Attend =>
            Scheduling.Attend_Class
              (Person => Database (Current),
               Class  => Get_String ("Class"));
         when Teach =>
            Scheduling.Teach_Class
              (Person => Database (Current),
               Class  => Get_String ("Class"));
         when Print =>
            for I in 1 .. Current loop
               Scheduling.Print (Database (I));
            end loop;
         when Quit =>
            exit;
      end case;
   end loop;
end Main;
--Main
--Scheduling_Body
with Ada.Text_IO; use Ada.Text_IO;
package body Scheduling is
   function Create (First_Name : String;
                    Last_Name  : String;
                    Kind       : Kind_T := Unknown)
                    return Person_T is
      Retval : Person_T (Kind);
   begin
      Retval.First_Name := Value (First_Name);
      Retval.Last_Name  := Value (Last_Name);
      return Retval;
   end Create;
   procedure Add_To_Schedule (Class    :        String;
                              Schedule : in out Schedule_T) is
   begin
      Schedule.Count                 := Schedule.Count + 1;
      Schedule.List (Schedule.Count) := Value (Class);
   end Add_To_Schedule;
   procedure Attend_Class (Person : in out Person_T;
                           Class  : in     String) is
      Kind : constant Kind_T := Person.Kind;
   begin
      case Person.Kind is
         when First_Year .. Fourth_Year =>
            Add_To_Schedule (Class, Person.Student_Schedule);
         when Grad =>
            Add_To_Schedule (Class, Person.Grad_Schedule);
         when others =>
            raise Failure;
      end case;
   end Attend_Class;
   procedure Teach_Class (Person : in out Person_T;
                          Class  : in     String) is
   begin
      case Person.Kind is
         when Grad =>
            Add_To_Schedule (Class, Person.Assistant_Schedule);
         when Professor =>
            Add_To_Schedule (Class, Person.Teaching_Schedule);
         when others =>
            raise Failure;
      end case;
   end Teach_Class;
   procedure Print_Schedule (Schedule : Schedule_T) is
   begin
      if Schedule.Count = 0 then
         Put_Line ("   <no classes>");
      else
         for I in 1 .. Schedule.Count loop
            Put_Line ("   " & Image (Schedule.List (I)));
         end loop;
      end if;
   end Print_Schedule;
   procedure Print (Person : in Person_T) is
   begin
      Put_Line
        (Image (Person.First_Name) & " " & Image (Person.Last_Name) & " (" &
         Kind_T'image (Person.Kind) & ")");
      case Person.Kind is
         when First_Year .. Fourth_Year =>
            Put_Line ("Taking:");
            Print_Schedule (Person.Student_Schedule);
         when Grad =>
            Put_Line ("Taking:");
            Print_Schedule (Person.Grad_Schedule);
            Put_Line ("Teaching:");
            Print_Schedule (Person.Assistant_Schedule);
         when Professor =>
            Put_Line ("Teaching:");
            Print_Schedule (Person.Teaching_Schedule);
         when Unknown =>
            null;
      end case;
   end Print;
end Scheduling;
--Scheduling_Body
--Scheduling_Spec
with Strings; use Strings;
package Scheduling is
   Failure : exception;
   type Kind_T is
     (Unknown, First_Year, Second_Year, Third_Year, Fourth_Year, Grad,
      Professor);
   type Schedule_T is private;
   type Person_T is private;
   function Create (First_Name : String;
                    Last_Name  : String;
                    Kind       : Kind_T := Unknown)
                    return Person_T;
   procedure Attend_Class (Person : in out Person_T;
                           Class  : in     String);
   procedure Teach_Class (Person : in out Person_T;
                          Class  : in     String);
   procedure Print (Person : in Person_T);
private
   Max_Schedule_Size : constant := 10;
   type Schedule_Array_T is array (1 .. Max_Schedule_Size) of String_T;
   type Schedule_T is record
      Count : Natural := 0;
      List  : Schedule_Array_T;
   end record;
   type Person_T (Kind : Kind_T := Unknown) is record
      First_Name : Strings.String_T;
      Last_Name  : Strings.String_T;
      case Kind is
         when Unknown =>
            null;
         when First_Year .. Fourth_Year =>
            Student_Schedule : Schedule_T;
         when Grad =>
            Grad_Schedule      : Schedule_T;
            Assistant_Schedule : Schedule_T;
         when Professor =>
            Teaching_Schedule : Schedule_T;
      end case;
   end record;
end Scheduling;
--Scheduling_Spec
--Strings_Body
package body Strings is
   function Value (S : String) return String_T is
   begin
      return (S'length, S);
   end Value;
   function Image (S : String_T) return String is
   begin
      return S.Text;
   end Image;
   function "&" (L, R : String_T) return String_T is
      Retval : constant String := L.Text & R.Text;
   begin
      return (Retval'length, Retval);
   end "&";
   function "&" (L : String_T;
                 R : String)
                 return String_T is
      Retval : constant String := L.Text & R;
   begin
      return (Retval'length, Retval);
   end "&";
   function "&" (L : String;
                 R : String_T)
                 return String_T is
      Retval : constant String := L & R.Text;
   begin
      return (Retval'length, Retval);
   end "&";
   function Element (S     : String_T;
                     Index : Natural)
                     return Character is
   begin
      return S.Text (Index);
   end Element;
   function Slice (S           : String_T;
                   First, Last : Natural)
                   return String_T is
      Retval : constant String := S.Text (First .. Last);
   begin
      return (Retval'length, Retval);
   end Slice;
   function Slice (S           : String_T;
                   First, Last : Natural)
                   return String is
   begin
      return S.Text (First .. Last);
   end Slice;
   function Length (S : String_T) return Natural is
   begin
      return S.Length;
   end Length;
end Strings;
--Strings_Body
--Strings_Spec
package Strings is
   type String_T is private;
   function Value (S : String) return String_T;
   function Image (S : String_T) return String;
   function Length (S : String_T) return Natural;
   function "&" (L, R : String_T) return String_T;
   function "&" (L : String_T;
                 R : String)
                 return String_T;
   function "&" (L : String;
                 R : String_T)
                 return String_T;
   function Element (S     : String_T;
                     Index : Natural)
                     return Character;
   function Slice (S           : String_T;
                   First, Last : Natural)
                   return String_T;
   function Slice (S           : String_T;
                   First, Last : Natural)
                   return String;
private
   Max_String_Length : constant := 132;
   subtype String_Length_T is Natural range 0 .. Max_String_Length;
   subtype String_Index_T is Natural range 1 .. String_Length_T'last;
   type String_T (Length : String_Length_T := 0) is record
      Text : String (1 .. Length);
   end record;
end Strings;
--Strings_Spec
