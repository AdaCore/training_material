--Calculator_Spec
package Calculator is

   Formatting_Error : exception;
   Divide_By_Zero   : exception;

   type Integer_T is range -1_000 .. 1_000;

   function Add (Left, Right : String)
                 return Integer_T;
   function Subtract (Left, Right : String)
                     return Integer_T;
   function Multiply (Left, Right : String)
                      return Integer_T;
   function Divide (Top, Bottom : String)
                    return Integer_T;

end Calculator;
--Calculator_Spec

with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Text_IO;           use Ada.Text_IO;
with Calculator;            use Calculator;
with Debug_Pkg;
procedure Main is

   Illegal_Operator : exception;

   type Operator_T is ('+', '-', '*', '/');

   procedure Parser
     (Str      :     String;
      Left     : out Unbounded_String;
      Operator : out Unbounded_String;
      Right    : out Unbounded_String) is
      I : Integer := Str'First;
   begin
      while I <= Str'Length and then Str (I) /= ' ' loop
         Left := Left & Str (I);
         I    := I + 1;
      end loop;
      while I <= Str'Length and then Str (I) = ' ' loop
         I := I + 1;
      end loop;
      while I <= Str'Length and then Str (I) /= ' ' loop
         Operator := Operator & Str (I);
         I        := I + 1;
      end loop;
      while I <= Str'Length and then Str (I) = ' ' loop
         I := I + 1;
      end loop;
      while I <= Str'Length and then Str (I) /= ' ' loop
         Right := Right & Str (I);
         I     := I + 1;
      end loop;
   end Parser;

--Main
begin
   loop
      declare
         Left, Operator, Right : Unbounded_String;
         Input                 : constant String := Get_Line;
      begin
         exit when Input'Length = 0;
         Parser (Input, Left, Operator, Right);
         case Element (Operator, 1) is
            when '+' =>
               Put_Line
                 ("  => " &
                  Integer_T'Image (Add (To_String (Left), To_String (Right))));
            when '-' =>
               Put_Line
                 ("  => " &
                  Integer_T'Image
                    (Subtract (To_String (Left), To_String (Right))));
            when '*' =>
               Put_Line
                 ("  => " &
                  Integer_T'Image
                    (Multiply (To_String (Left), To_String (Right))));
            when '/' =>
               Put_Line
                 ("  => " &
                  Integer_T'Image
                    (Divide (To_String (Left), To_String (Right))));
            when others =>
               raise Illegal_Operator;
         end case;
      exception
         when The_Err : others =>
            Debug_Pkg.Save_Occurrence (The_Err);
      end;
   end loop;
   Debug_Pkg.Print_Exceptions;
--Main
end Main;

--Calculator_Body
package body Calculator is

   function Value (Str : String) return Integer_T is
   begin
      return Integer_T'Value (Str);
   exception
      when Constraint_Error =>
         raise Formatting_Error;
   end Value;

   function Add (Left, Right : String) return Integer_T is
       (Value (Left) + Value (Right));
   function Subtract (Left, Right : String) return Integer_T is
       (Value (Left) - Value (Right));
   function Multiply (Left, Right : String) return Integer_T is
       (Value (Left) * Value (Right));
   function Divide (Top, Bottom : String) return Integer_T is
     (if Value (Bottom) = 0 then
        raise Divide_By_Zero
      else
        Value (Top) / Value (Bottom));

end Calculator;
--Calculator_Body

--Debug
with Ada.Exceptions;
package Debug_Pkg is
procedure Save_Occurrence (X : Ada.Exceptions.Exception_Occurrence);
   procedure Print_Exceptions;
end Debug_Pkg;

with Ada.Exceptions;
with Ada.Text_IO;
use type Ada.Exceptions.Exception_Id;
package body Debug_Pkg is

   Exceptions     : array (1 .. 100) of Ada.Exceptions.Exception_Occurrence;
   Next_Available : Integer := 1;

   procedure Save_Occurrence (X : Ada.Exceptions.Exception_Occurrence) is
   begin
      Ada.Exceptions.Save_Occurrence (Exceptions (Next_Available), X);
      Next_Available := Next_Available + 1;
   end Save_Occurrence;

   procedure Print_Exceptions is
   begin
      for I in 1 .. Next_Available - 1 loop
         declare
            E    : Ada.Exceptions.Exception_Occurrence renames Exceptions (I);
            Flag : Character := ' ';
         begin

            if Ada.Exceptions.Exception_Identity (E) =
              Constraint_Error'Identity
            then
               Flag := '*';
            end if;
            Ada.Text_IO.Put_Line
              (Flag & " " & Ada.Exceptions.Exception_Information (E));
         end;
      end loop;
   end Print_Exceptions;

end Debug_Pkg;
--Debug
