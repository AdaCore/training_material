--Accounts_Keys
package body Accounts is
   subtype Key_T is String (1 .. 20);
   type User_Key_Data_T is record
      Key : Key_T;
   end record;
   function Flip (C : Character) return Character is
      I : constant Integer := Character'pos (C);
      J : constant Integer := Character'pos (Character'last) - I;
   begin
      return Character'val (J);
   end Flip;
   function Secure_Key (Str : String) return User_Key_T is
      Retval : User_Key_T := new User_Key_Data_T;
      Key    : Key_T renames Retval.Key;
      I      : Integer    := Key'first;
      J      : Integer    := Str'first;
   begin
      while I <= Key'last loop
         Key (I) := Flip (Str (J));
         I       := I + 1;
         if J = Str'last then
            J := Str'first;
         else
            J := J + 1;
         end if;
      end loop;
      return Retval;
   end Secure_Key;
--Accounts_Keys
--Accounts_Body
   type Transactions_List_T is array (1 .. 1_000) of Funds_T;
   type Transactions_T is record
      List : Transactions_List_T;
      Last : Integer := 0;
   end record;
   Empty_Transaction_List : constant Transactions_T :=
     (List => (others => 0.0), Last => 0);
   type Unique_Id_T is mod 2**32;
   Next_Available_Id : Unique_Id_T := 1;
   type Account_Data_T is record
      Unique_Id   : Unique_Id_T;
      User_Key    : User_Key_Data_T;
      Deposits    : Transactions_T;
      Withdrawals : Transactions_T;
   end record;
   procedure Verify (Account : Account_T;
                     Key     : User_Key_T) is
   begin
      if Account.User_Key /= Key.all then
         raise Illegal_Access;
      end if;
   end Verify;
   function Create (Key : User_Key_T) return Account_T is
      Retval : Account_T :=
        new Account_Data_T'
          (Unique_Id   => Next_Available_Id, User_Key => Key.all,
           Deposits    => Empty_Transaction_List,
           Withdrawals => Empty_Transaction_List);
   begin
      return Retval;
   end Create;
   procedure Append (List   : in out Transactions_T;
                     Amount :        Funds_T) is
   begin
      List.Last             := List.Last + 1;
      List.List (List.Last) := Amount;
   end Append;
   procedure Deposit (Account : Account_T;
                      Key     : User_Key_T;
                      Amount  : Funds_T) is
   begin
      Verify (Account, Key);
      Append (Account.Deposits, Amount);
   end Deposit;
   procedure Withdraw (Account : Account_T;
                       Key     : User_Key_T;
                       Amount  : Funds_T) is
   begin
      Verify (Account, Key);
      Append (Account.Withdrawals, Amount);
   end Withdraw;
   function Sum (List : Transactions_T) return Funds_T is
      Retval : Funds_T := 0.0;
   begin
      for I in 1 .. List.Last loop
         Retval := Retval + List.List (I);
      end loop;
      return Retval;
   end Sum;
   function Balance (Account : Account_T;
                     Key     : User_Key_T)
                     return Funds_T is
   begin
      Verify (Account, Key);
      return Sum (Account.Deposits) - Sum (Account.Withdrawals);
   end Balance;
end Accounts;
--Accounts_Body
--Accounts_Spec
package Accounts is
   Illegal_Access : exception;
   type User_Key_T is private;
   type Account_T is private;
   type Funds_T is delta 0.01 range -9_999.99 .. 9_999.99;
   function Secure_Key (Str : String) return User_Key_T;
   function Create (Key : User_Key_T) return Account_T;
   procedure Deposit (Account : Account_T;
                      Key     : User_Key_T;
                      Amount  : Funds_T);
   procedure Withdraw (Account : Account_T;
                       Key     : User_Key_T;
                       Amount  : Funds_T);
   function Balance (Account : Account_T;
                     Key     : User_Key_T)
                     return Funds_T;
private
   type User_Key_Data_T;
   type User_Key_T is access User_Key_Data_T;
   type Account_Data_T;
   type Account_T is access Account_Data_T;
end Accounts;
--Accounts_Spec
with Ada.Characters.Handling; use Ada.Characters.Handling;
with Ada.Text_IO;             use Ada.Text_IO;
package body Input is
   function Get_String
     (Prompt : String)
      return String is
      Str  : String (1 .. 100);
      Last : Integer;
   begin
      Put (Prompt & " > ");
      Ada.Text_IO.Get_Line (Str, Last);
      return Str (1 .. Last);
   end Get_String;
   function Get_Number
     (Prompt : String)
      return Integer_T is
   begin
      loop
         declare
            Retval : constant String := Get_String (Prompt);
         begin
            if Retval'length > 0 then
               return Integer_T'value (Retval);
            else
               raise Input_Canceled;
            end if;
         exception
            when others =>
               Put_Line ("Invalid input");
         end;
      end loop;
   end Get_Number;
   function Get_Enum
     (Prompt : String)
      return Enum_T is
   begin
      for E in Enum_T'range loop
         Put_Line
           (Integer'image (1 + Enum_T'pos (E)) & "> " & Enum_T'image (E));
      end loop;
      loop
         declare
            I : constant String := Get_String (Prompt);
         begin
            if I'length = 0 then
               raise Input_Canceled;
            end if;
            return Enum_T'val (Natural'value (I) - 1);
         exception
            when Input_Canceled =>
               raise Input_Canceled;
            when others =>
               Put_Line ("Illegal value");
         end;
      end loop;
   end Get_Enum;
   function Internal_Get_Integer is new Get_Number (Integer);
   function Internal_Get_Natural is new Get_Number (Natural);
   function Internal_Get_Positive is new Get_Number (Positive);
   function Get_Integer
     (Prompt : String)
      return Integer renames Internal_Get_Integer;
   function Get_Natural
     (Prompt : String)
      return Natural renames Internal_Get_Natural;
   function Get_Positive
     (Prompt : String)
      return Positive renames Internal_Get_Positive;
end Input;
package Input is
   Input_Canceled : exception;
   function Get_String
     (Prompt : String)
      return String;
   function Get_Integer
     (Prompt : String)
      return Integer;
   function Get_Natural
     (Prompt : String)
      return Natural;
   function Get_Positive
     (Prompt : String)
      return Positive;
   generic
      type Enum_T is (<>);
   function Get_Enum
     (Prompt : String)
      return Enum_T;
   generic
      type Integer_T is range <>;
   function Get_Number
     (Prompt : String)
      return Integer_T;
end Input;
--Main
with Accounts;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Text_IO;           use Ada.Text_IO;
with Input;                 use Input;
procedure Main is
   type Commands_T is (Create, Deposit, Withdraw, Balance, Quit);
   function Command is new Get_Enum (Commands_T);
   type Database_T is record
      Key     : Unbounded_String;
      Account : Accounts.Account_T;
   end record;
   Database       : array (1 .. 100) of Database_T;
   Next_Available : Integer := 1;
   function Index
     (Key : String)
      return Integer is
   begin
      for I in 1 .. Next_Available - 1 loop
         if Database (I).Key = Key then
            return I;
         end if;
      end loop;
      Put_Line (Key & " not found");
      return Database'first - 1;
   end Index;
begin
   loop
      case Command ("Select command") is
         when Quit =>
            exit;
         when Create =>
            declare
               Key : constant String := Get_String ("New User Key");
            begin
               Database (Next_Available).Key     := To_Unbounded_String (Key);
               Database (Next_Available).Account :=
                 Accounts.Create (Accounts.Secure_Key (Key));
               Next_Available := Next_Available + 1;
            end;
         when Deposit =>
            declare
               Key : constant String  := Get_String ("Existing User Key");
               Idx : constant Integer := Index (Key);
            begin
               if Idx in Database'range then
                  Accounts.Deposit
                    (Account => Database (Idx).Account,
                     Key     => Accounts.Secure_Key (Key),
                     Amount  =>
                       Accounts.Funds_T'value
                         (Get_String ("Amount to deposit")));
               end if;
            end;
         when Withdraw =>
            declare
               Key : constant String  := Get_String ("Existing User Key");
               Idx : constant Integer := Index (Key);
            begin
               if Idx in Database'range then
                  Accounts.Withdraw
                    (Account => Database (Idx).Account,
                     Key     => Accounts.Secure_Key (Key),
                     Amount  =>
                       Accounts.Funds_T'value
                         (Get_String ("Amount to withdraw")));
               end if;
            end;
         when Balance =>
            declare
               Key : constant String  := Get_String ("Existing User Key");
               Idx : constant Integer := Index (Key);
            begin
               if Idx in Database'range then
                  Put_Line
                    ("Balance: " & Accounts.Funds_T'image (Accounts.Balance
                          (Account => Database (Idx).Account,
                           Key     => Accounts.Secure_Key (Key))));
               end if;
            end;
         when others =>
            null;
      end case;
   end loop;
end Main;
--Main
