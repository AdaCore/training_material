--Colors
package Colors is
   type Color_T is (Red, Yellow, Green, Blue, Black);
   type Color_Set_T is private;
   Empty_Set : constant Color_Set_T;
   procedure Add (Set   : in out Color_Set_T;
                  Color :        Color_T);
   procedure Remove (Set   : in out Color_Set_T;
                     Color :        Color_T);
   function Image (Set : Color_Set_T) return String;
private
   type Color_Set_Array_T is array (Color_T) of Boolean;
   type Color_Set_T is record
      Values : Color_Set_Array_T := (others => False);
   end record;
   Empty_Set : constant Color_Set_T := (Values => (others => False));
end Colors;

with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
package body Colors is
   procedure Add (Set   : in out Color_Set_T;
                  Color :        Color_T) is
   begin
      Set.Values (Color) := True;
   end Add;
   procedure Remove (Set   : in out Color_Set_T;
                     Color :        Color_T) is
   begin
      Set.Values (Color) := False;
   end Remove;
   function Image (Set : Color_Set_T) return String is
      Retval : Unbounded_String := Null_Unbounded_String;
   begin
      for Color in Set.Values'range loop
         if Set.Values (Color) then
            Retval := Retval & Color_T'image (Color) & " ";
         end if;
      end loop;
      return To_String (Retval);
   end Image;
end Colors;
--Colors
--Flags_Body_1
package body Flags is
   procedure Add
     (Map         : in out Map_T;
      Key         :        Key_T;
      Description :        Colors.Color_Set_T;
      Success     :    out Boolean) is
   begin
      for I in 1 .. Map.Length loop
         if Map.Values (I).Key = Key then
            Success := False;
            return;
         end if;
      end loop;
      declare
         New_Item : Map_Element_T := (Key => Key, Description => Description);
      begin
         Map.Length              := Map.Length + 1;
         Map.Values (Map.Length) := New_Item;
      end;
   end Add;
   procedure Remove
     (Map     : in out Map_T;
      Key     :        Key_T;
      Success :    out Boolean) is
   begin
      Success := False;
      for I in 1 .. Map.Length loop
         if Map.Values (I).Key = Key then
            Map.Values (I .. Map.Length - 1) :=
              Map.Values (I + 1 .. Map.Length);
            Success := True;
            exit;
         end if;
      end loop;
   end Remove;
   procedure Modify
     (Map         : in out Map_T;
      Key         :        Key_T;
      Description :        Colors.Color_Set_T;
      Success     :    out Boolean) is
   begin
      Success := False;
      for I in 1 .. Map.Length loop
         if Map.Values (I).Key = Key then
            Map.Values (I).Description := Description;
            Success                    := True;
            exit;
         end if;
      end loop;
   end Modify;
--Flags_Body_1
--Flags_Body_2
   function Exists
     (Map : Map_T;
      Key : Key_T)
      return Boolean is
   begin
      for I in 1 .. Map.Length loop
         if Map.Values (I).Key = Key then
            return True;
         end if;
      end loop;
      return False;
   end Exists;
   function Get
     (Map : Map_T;
      Key : Key_T)
      return Map_Element_T is
      Ret_Val : Map_Element_T;
   begin
      for I in 1 .. Map.Length loop
         if Map.Values (I).Key = Key then
            Ret_Val := Map.Values (I);
            exit;
         end if;
      end loop;
      return Ret_Val;
   end Get;
   function Image
     (Item : Map_Element_T)
      return String is
   begin
      return Key_T'image (Item.Key) & " => " & Colors.Image (Item.Description);
   end Image;
   function Image
     (Flag : Map_T)
      return String is
      Ret_Val : String (1 .. 1_000);
      Next    : Integer := Ret_Val'first;
   begin
      for I in 1 .. Flag.Length loop
         declare
            Str : constant String := Image (Flag.Values (I));
         begin
            Ret_Val (Next .. Next + Str'length) :=
              Image (Flag.Values (I)) & Ascii.Lf;
            Next := Next + Str'length + 1;
         end;
      end loop;
      return Ret_Val (1 .. Next - 1);
   end Image;
end Flags;
--Flags_Body_2
--Flags_Spec
with Colors;
package Flags is
   type Key_T is (Boston, London, Paris, Rome);
   type Map_Element_T is private;
   type Map_T is private;
   procedure Add
     (Map         : in out Map_T;
      Key         :        Key_T;
      Description :        Colors.Color_Set_T;
      Success     :    out Boolean);
   procedure Remove
     (Map     : in out Map_T;
      Key     :        Key_T;
      Success :    out Boolean);
   procedure Modify
     (Map         : in out Map_T;
      Key         :        Key_T;
      Description :        Colors.Color_Set_T;
      Success     :    out Boolean);
   function Exists
     (Map : Map_T;
      Key : Key_T)
      return Boolean;
   function Get
     (Map : Map_T;
      Key : Key_T)
      return Map_Element_T;
   function Image
     (Item : Map_Element_T)
      return String;
   function Image
     (Flag : Map_T)
      return String;
private
   type Map_Element_T is record
      Key         : Key_T              := Boston;
      Description : Colors.Color_Set_T := Colors.Empty_Set;
   end record;
   type Map_Array_T is array (1 .. 100) of Map_Element_T;
   type Map_T is record
      Values : Map_Array_T;
      Length : Natural := 0;
   end record;
end Flags;
--Flags_Spec
with Ada.Characters.Handling; use Ada.Characters.Handling;
with Ada.Text_IO;             use Ada.Text_IO;
package body Input is
   function Get_String
     (Prompt : String)
      return String is
      Str  : String (1 .. 100);
      Last : Integer;
   begin
      Put (Prompt & " > ");
      Ada.Text_IO.Get_Line (Str, Last);
      return Str (1 .. Last);
   end Get_String;
   function Get_Number
     (Prompt : String)
      return Integer_T is
   begin
      loop
         declare
            Retval : constant String := Get_String (Prompt);
         begin
            if Retval'length > 0 then
               return Integer_T'value (Retval);
            else
               raise Input_Canceled;
            end if;
         exception
            when others =>
               Put_Line ("Invalid input");
         end;
      end loop;
   end Get_Number;
   function Get_Enum
     (Prompt : String)
      return Enum_T is
   begin
      for E in Enum_T'range loop
         Put_Line
           (Integer'image (1 + Enum_T'pos (E)) & "> " & Enum_T'image (E));
      end loop;
      loop
         declare
            I : constant String := Get_String (Prompt);
         begin
            if I'length = 0 then
               raise Input_Canceled;
            end if;
            return Enum_T'val (Natural'value (I) - 1);
         exception
            when Input_Canceled =>
               raise Input_Canceled;
            when others =>
               Put_Line ("Illegal value");
         end;
      end loop;
   end Get_Enum;
   function Internal_Get_Integer is new Get_Number (Integer);
   function Internal_Get_Natural is new Get_Number (Natural);
   function Internal_Get_Positive is new Get_Number (Positive);
   function Get_Integer
     (Prompt : String)
      return Integer renames Internal_Get_Integer;
   function Get_Natural
     (Prompt : String)
      return Natural renames Internal_Get_Natural;
   function Get_Positive
     (Prompt : String)
      return Positive renames Internal_Get_Positive;
end Input;
package Input is
   Input_Canceled : exception;
   function Get_String
     (Prompt : String)
      return String;
   function Get_Integer
     (Prompt : String)
      return Integer;
   function Get_Natural
     (Prompt : String)
      return Natural;
   function Get_Positive
     (Prompt : String)
      return Positive;
   generic
      type Enum_T is (<>);
   function Get_Enum
     (Prompt : String)
      return Enum_T;
   generic
      type Integer_T is range <>;
   function Get_Number
     (Prompt : String)
      return Integer_T;
end Input;
--Main
with Ada.Text_IO; use Ada.Text_IO;
with Colors;
with Flags;
with Input;       use Input;
procedure Main is
   Map : Flags.Map_T;
   function Get_Flag is new Get_Enum (Flags.Key_T);
   function Get_Color is new Get_Enum (Colors.Color_T);
   function Get_Colors return Colors.Color_Set_T is
      Ret_Val : Colors.Color_Set_T;
   begin
      loop
         begin
            Colors.Add (Ret_Val, Get_Color ("Select a color"));
         exception
            when others =>
               exit;
         end;
      end loop;
      return Ret_Val;
   end Get_Colors;
begin
   loop
      declare
         Key         : Flags.Key_T;
         Description : Colors.Color_Set_T;
         Success     : Boolean;
      begin
         Ada.Text_IO.New_Line;
         Key         := Get_Flag ("Select flag");
         Description := Get_Colors;
         if Flags.Exists (Map, Key) then
            Flags.Modify (Map, Key, Description, Success);
         else
            Flags.Add (Map, Key, Description, Success);
         end if;
      exception
         when Input_Canceled =>
            exit;
      end;
   end loop;
   Put_Line (Flags.Image (Map));
end Main;
--Main
