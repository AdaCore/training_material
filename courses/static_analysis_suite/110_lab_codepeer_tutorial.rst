*************************
Lab - CodePeer Tutorial
*************************

..
    Coding language

.. role:: ada(code)
    :language: Ada

.. role:: C(code)
    :language: C

.. role:: cpp(code)
    :language: C++

..
    Math symbols

.. |rightarrow| replace:: :math:`\rightarrow`
.. |forall| replace:: :math:`\forall`
.. |exists| replace:: :math:`\exists`
.. |equivalent| replace:: :math:`\iff`
.. |le| replace:: :math:`\le`
.. |ge| replace:: :math:`\ge`
.. |lt| replace:: :math:`<`
.. |gt| replace:: :math:`>`

..
    Miscellaneous symbols

.. |checkmark| replace:: :math:`\checkmark`

===========
Lab Setup
===========

--------------------
Using CodePeer Lab
--------------------

* This lab is equivalent to the Tutorial available in :menu:`Help` |rightarrow| :menu:`CodePeer` |rightarrow| :menu:`CodePeer Tutorial`

  * For more in-depth analysis, follow that tutorial!

* In this lab we will examine some sample code for the messages generated during analysis

* Use :toolname:`GNAT Studio` to open the :filename:`default.gpr` project in the :filename:`110_lab_codepeer_tutorial` folder

------------------
Perform Analysis
------------------

.. container:: columns

  .. container:: column

    * Select the menu :menu:`CodePeer` |rightarrow| :menu:`Analyze All` in the menu bar at the top.

      .. image:: codepeer/menu_analyze_all.png

      * Note the :toolname:`CodePeer` report window

  .. container:: column

    * The report window displays some information

      * Counts for each message type

        .. image:: codepeer/tutorial_report.png

      * Medium level messages

        .. image:: codepeer/tutorial_messages_medium.png

--------------------
Filtering Analysis
--------------------

* Clicking on the filters on the right side changes the information presented

  * Only in the *Locations* view
  * Report maintains all information

* Uncheck the box **medium** in Message ranking.

  * This clears the location view.

* Check the box **low** in Message ranking.

  * The location view now reports the low messages only.

    .. image:: codepeer/tutorial_messages_low.png
      :width: 50%

* Undo these changes to recover medium messages only.

========================
Understanding Messages
========================

---------------------
Message Information
---------------------

.. container:: columns

  .. container:: column

    * In the locations view, click in the tree on the ``+`` sign (or triangle) at the left of :file:`tokens.adb`.

      .. image:: codepeer/tutorial_l26_location.png

    * Click on the message reported at line 26. This opens the file :file:`tokens.adb` at line 26.

  .. container:: column

    .. image:: codepeer/tutorial_l26_code.png

    .. container:: latex_environment tiny

      * Message gives following information

        * Ranking

          * **High**, **Medium**, **Low**
          * Indication of severity and certainty of the message
          * Higher ranking = more interesting/likely to occur

        * Check

          * Short description of problem.

        * Explanation

          * More detail if available

--------------------
Analyzing Messages
--------------------

* Expression at line 26 is accessing at the first index in local variable :ada:`Word`

  * Initialized at line 18 with a call to :ada:`Input.Next_Word`
  * Will raise a :ada:`Constraint_Error` if :ada:`Input.Next_Word` returns empty string.

* Go to the definition of function :ada:`Input.Next_Word`.

* Annotations generated by CodePeer displayed before the definition of :ada:`Next_Word` on line 184.

  .. image:: codepeer/tutorial_next_word_annotations.png
    :width: 40%

--------------------------
Manipulating Annotations
--------------------------

* Hide these annotations by clicking on the right mouse button and selecting :menu:`CodePeer` |rightarrow| :menu:`Hide annotations`.

.. image:: codepeer/tutorial_next_word_hide_annotations.png
  :width: 30%

* Re-display these annotations by clicking on the right mouse button and selecting :menu:`CodePeer` |rightarrow| :menu:`Show annotations`.

---------------------------
Understanding Annotations
---------------------------

* In postconditions, you can see that CodePeer computed

  * Possible range of ``1..1_024`` for the application of attribute :ada:`First`
  * Possible range of ``0..1_023`` for the application of attribute :ada:`Last`
  * This means :ada:`Result'First` |rightarrow| 1 and :ada:`Result'Last` |rightarrow| 0, so an empty string is possible

* In :ada:`Next_Word`, an empty string is returned when the first character read is not in :ada:`Printable_Character`.

* To protect against this error, return to file :file:`tokens.adb` at line 26

* Insert the following code before the case statement:

  .. code:: Ada

     if Word = "" then
        raise Except.User_Error;
     end if;

* Re-run CodePeer by selecting the menu :menu:`CodePeer` |rightarrow| :menu:`Analyze All`.
* Notice that the error on :file:`tokens.adb` has disappeared.

==========
Warnings
==========

----------------------------
Warnings are Coding Issues
----------------------------

* Warnings refer to potential logic errors:

  * Dead code
  * Test or condition predetermined
  * Unused assignment
  * Etc.

* (Same ranking scheme as checks)

---------------------
Examining a Warning
---------------------

* In the locations view, click on the message reported at line 41 of :file:`stack.adb`. 

  * Precondition computed by CodePeer for variable :ada:`Last` is suspicious

    * Not a continuous range of values.

    .. code:: Ada

      --  Preconditions:
      --    Last in (2..199, 201)

    * Note the hole - 199 and 201 are valid, but 200 is not
    * 200 is the value of :ada:`Tab'Last` - indicating full stack, so we shouldn't call :ada:`Push` when stack is full

  * Why is 201 valid?

    * What happens when we call :ada:`Push` with :ada:`Last` is 201?
    * Test on line 43 is false, so execution continues until line 49 :ada:`Last` is assigned the value 200 (201-1)!
    * We are decrementing :ada:`Last` in :ada:`Push` rather than incrementing it!

* Correct the faulty line
* Re-run CodePeer.

=================
False Positives
=================

---------------------------------
When a Problem is Not a Problem
---------------------------------

* Some messages are not actual errors

  * False positive means :toolname:`CodePeer` thinks it might fail when it actually cannot

* Allow low messages to be displayed by checking the box **low** in Message ranking.

* In locations view, click on message reported on code you inserted earlier in the lab on line 26 of :file:`tokens.adb`.

  * Message says that an exception might be raised

    * Which is what we wanted to happen!

* Click on the message reported at line 191 of :file:`input.adb`.

  * Message says :ada:`First_Char` might be greater than :ada:`Line_Size` (1024).

    * This can't happen the way the code is written

--------------------------------------
Marking an Issue as a False Positive
--------------------------------------

* You can choose to ignore a false positive or mark it as reviewed

  * Reviewed messages will not show up in future runs

* Click on *Edit* icon displayed in front of CodePeer messages in the locations view.

  .. image:: codepeer/tutorial_edit.png

  * This opens a window where you can enter a manual analysis of the message

    .. image:: codepeer/tutorial_edit_window.png

* Change its *New status* to **Not a bug**.

=============
Annotations
=============

-------------------------
Basic Annotations (1/2)
-------------------------

* Open file :file:`stack.adb` and look at the annotations for procedure :ada:`Push`.

  .. code:: ada

     --  Preconditions:
     --    Last <= 199
     --    V /= null
     --    V.E'Initialized

  * Preconditions are constraints that should be respected

    * :ada:`Last` should be <= 199 - to prevent overflow
    * :ada:`V` should not be null
    * :ada:`V.E` needs to be initialized

* Where can this precondition be traced from?

  * Some come from checks inside the subprogram
  * Others come from called subprograms (directly or indirectly)

-------------------------
Basic Annotations (2/2)
-------------------------

.. code:: ada

  --  Postconditions:
  --    Last = Last'Old + 1
  --    Last in 1..200
  --    Tab(1..200) = One-of{V, Tab(1..200)'Old}

* Postconditions are the "state" after the call

  * :ada:`Last` will be incremented by 1
  * :ada:`Last` will be in the range 1 .. 200
  * (See next section for an explanation of the last postcondition)

---------------------------
Complex Annotations (1/2)
---------------------------

.. container:: latex_environment tiny

  * Open file :file:`tokens.adb` and look at the preconditions generated for procedure :ada:`Process`:

    .. code:: ada

      --  Preconditions:
      --    T.Kind /= Op or Stack'Body.Last in 2..200
      --    T.Kind /= Op or Stack'Body.Tab(Stack'Body.Last - 1) /= null
      --    T.Kind /= Op or Stack'Body.Tab(Stack'Body.Last) /= null
      --    T.Kind /= Op or Stack'Body.Tab(1..200).E'Initialized
      --    T.Kind /= Op or T.Op'Initialized
      --    T.Kind <= Op or Stack'Body.Last <= 200 or T.Instr /= Print
      --    T.Kind <= Op or Stack'Body.Last = 0 or T.Instr /= Print or Stack'Body.Tab(Stack'Body.Last) /= null
      --    T.Kind <= Op or Stack'Body.Last = 0 or T.Instr /= Print or Stack'Body.Tab(1..200).E'Initialized
      --    T.Kind <= Op or T.Instr <= Print
      --    T.Kind >= Op or Stack'Body.Last <= 199
      --    T.Kind >= Op or T.Val /= null
      --    T.Kind >= Op or T.Val.E'Initialized

  * :ada:`-- T.Kind /= Op or Stack'Body.Last in 2..200`

    * If :ada:`T.Kind = Op` then :ada:`Last` will be 2..200
    * Constraint on :ada:`Last` only occurs if :ada:`T.Kind = Op`

---------------------------
Complex Annotations (2/2)
---------------------------

.. container:: latex_environment tiny

  * Look now at the postconditions generated for procedure :ada:`Process`:

    .. code:: ada

      --  Postconditions:
      --    Stack'Body.Last = One-of{Stack'Body.Last'Old + 1, Stack'Body.Last'Old - 2, Stack'Body.Last'Old - 1, 0, Stack'Body.Last'Old}
      --    Stack'Body.Last <= 200
      --    Stack'Body.Tab(1..200) = One-of{T.Val, Stack'Body.Tab(1..200)'Old, new Value_Info(in values.operations.process)#1'Address}
      --    new Value_Info(in values.operations.process)#1.<num objects> in 0..1
      --    new Value_Info(in values.operations.process)#1.E'Initialized

  * :ada:`-- Stack'Body.Tab(1..200) = One-of{T.Val, Stack'Body.Tab(1..200)'Old, ...`

    * ``One-of`` means the value is one of a (specified) list of possible values
